<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Blockly Demo: Adventure Blockly</title>
  <script src="../../blockly_uncompressed.js"></script>
  <script src="../../generators/javascript.js"></script>
  <script src="../../generators/javascript/logic.js"></script>
  <script src="../../generators/javascript/loops.js"></script>
  <script src="../../generators/javascript/math.js"></script>
  <script src="../../generators/javascript/text.js"></script>
  <script src="../../generators/javascript/lists.js"></script>
  <script src="../../generators/javascript/colour.js"></script>
  <script src="../../generators/javascript/variables.js"></script>
  <script src="../../generators/javascript/procedures.js"></script>
  <script src="../../msg/messages.js"></script>
  <script src="../../blocks/logic.js"></script>
  <script src="../../blocks/loops.js"></script>
  <script src="../../blocks/math.js"></script>
  <script src="../../blocks/text.js"></script>
  <script src="../../blocks/lists.js"></script>
  <script src="../../blocks/colour.js"></script>
  <script src="../../blocks/variables.js"></script>
  <script src="../../blocks/procedures.js"></script>
  <script src="JS-Interpreter/acorn.js"></script>
  <script src="JS-Interpreter/interpreter.js"></script>
  <script src="blocks.js"></script>
    
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      background-color: #fff;
      font-family: sans-serif;
      overflow: hidden;
    }
    h1 {
      font-weight: normal;
      font-size: 140%;
    }
    section {
      float: left;
      width : 70%;
    }
    aside {
      float: right;
      width: 30%;
    }
  </style>
</head>
<body>
<table>
  <tr>
   <td>
    <h1><a href="https://developers.google.com/blockly/">Blockly</a> &gt;
      <a href="../index.html">Demos</a> &gt; Adventure Blockly</h1>

      <p>Make your own adventure through text, speech, and pictures. Create your own or check out some of our examples (link).</p>

      <p id = "logText">This is where logging messages go.</p>

      <p>
        <button onclick="showCode()">Show JavaScript</button>   
        <button onclick="runCode()">Start Adventure</button>
      </p>

  <aside>
       <p id="displayText"> Your story's text will be shown here.</p>

       <img id = "displayPic" src = "http://cdn3-www.cattime.com/assets/uploads/2011/08/best-kitten-names-1.jpg" alt="Image chosen by user" style = "width:40%;height:40%;">
  </aside>


  <section id="blocklyDiv" style= "height: 480px; width: 900px;"></div>    

  <xml id="toolbox" style="display: none">
    <category name="Listen">
      <block type="listen_if"></block>
      <block type="listen_bool"></block>
      <block type="listen_text"></block>
    </category>
    <category name="Display">
      <block type="display_img"></block>
      <block type="display_text"></block>
      <block type="display_pause"></block>
    </category>
    <category name="Usual">
      <block type="math_number"></block>
      <block type="controls_if"></block>
      <block type="logic_compare"></block>
      <block type="controls_repeat_ext"></block>
      <block type="math_number"></block>
      <block type="math_arithmetic"></block>
    </category>
    <category name="Text">
      <block type="text"></block>
      <block type="text_print"></block>
    </category>
    <category name="Speak">
      <block type="speech_speak"></block>
    </category>
  </xml>
  </section>

  <script>

    var recognizableWords = []; //keeps track of all the words that the recognizer should listen for

    var workspace = Blockly.inject('blocklyDiv',  
        {media: '../../media/',
         toolbox: document.getElementById('toolbox')});

    //allows for portability across different browsers
    var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;
    var SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList;
    var SpeechRecognitionEvent = SpeechRecognitionEvent || webkitSpeechRecognitionEvent;

    /**
     * Associated with the "Show Javascript button", outputs the code in an alert window
     * TODO(edauterman): Figure out how to format the code correctly in the HTML (with line breaks)
     */
    var showCode = function() {   
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
      var code = "Your code: \n" + Blockly.JavaScript.workspaceToCode(workspace);
      document.getElementById('logText').textContent = code;
      alert(code);
    };


    /**
     * Generate JavaScript code and run it using the JS Interpreter, prints code to console for debugging. Defines 
     * wrappers (syncronously and asyncronously) to handle certain blocks
     * TODO(edauterman): Is there a way to decompose initFunc better while not creating any scoping problems? 
     * TODO(edauterman): Remove names after function and give them unique names. 
     * NOTE: If move the wrapper functions outside of runCode, then myInterpreter is not in scope (needs to be a 
     * local because it needs to be recreated each time to allow for changes to code), and myInterpreter can't be
     * passed as an argument because the order and type of arguments is defined by JS Interpreter.
     */
    var runCode = function() {
      var code = Blockly.JavaScript.workspaceToCode(workspace);
      window.console.log(code);

      //used to define wrappers for myInterpreter
      var initFunc = function(myInterpreter,scope) {

        //alert
        var alertWrapper = function(text) {
          text = text ? text.toString() : '';
          return myInterpreter.createPrimitive(alert(text));
        };
        myInterpreter.setProperty(scope, 'alert',
            myInterpreter.createNativeFunction(alertWrapper));

        //listen_branch, used for listen_if and listen_bool
        var listenBranchWrapper = function(word,callback) {
          word = word ? word.toString() : '';
          var localRecognizer = new SpeechRecognition();
          updateGrammars(localRecognizer);
          localRecognizer.start();
          logMessage(myInterpreter,"Listening...");
          localRecognizer.onresult = function() {
              var speechResult = event.results[0][0].transcript;
              logMessage(myInterpreter, 'You said: \"' + speechResult + '\"');
              callback(myInterpreter.createPrimitive(speechResult == word));
          };
        };
        myInterpreter.setProperty(scope,'listen_branch', myInterpreter.createAsyncFunction(listenBranchWrapper));

        //listen_text
        var listenTextWrapper = function(callback) {
          var localRecognizer = new SpeechRecognition();
          updateGrammars(localRecognizer);
          localRecognizer.start();
          logMessage(myInterpreter,"Listening...");
          localRecognizer.onresult = function() {
              var speechResult = event.results[0][0].transcript;
              logMessage(myInterpreter, 'You said: \"' + speechResult + '\"');
              callback(myInterpreter.createPrimitive(speechResult));
          };
        };
        myInterpreter.setProperty(scope,'listen_text', myInterpreter.createAsyncFunction(listenTextWrapper));

        //display_img
        var imageWrapper = function(url) {
          url = url ? url.toString() : '';
          return myInterpreter.createPrimitive(window.document.getElementById('displayPic').src = url);
        };
        myInterpreter.setProperty(scope, 'displayImage',
            myInterpreter.createNativeFunction(imageWrapper));

        //pause
        var pauseWrapper = function(time,callback) {
          time = time ? time.toString() : '';
          timeVar = parseInt(time);
          window.console.log(timeVar);  
          var resume = function() {
            callback();
          };
          return myInterpreter.createPrimitive(window.setTimeout(resume,timeVar));
        };
        myInterpreter.setProperty(scope, 'pause',
            myInterpreter.createAsyncFunction(pauseWrapper));

        //speech
        var speechWrapper = function(wordsToSay,callback){
          wordsToSay = wordsToSay ? wordsToSay.toString() : '';
          if ('speechSynthesis' in window) {
            localMsg = new SpeechSynthesisUtterance(wordsToSay);
            window.speechSynthesis.speak(localMsg);
          // Synthesis support. Make your web apps talk!
          } else {
            logMessage(myInterpreter,"speechSynthesis not found. Text to speech capability under Web Speech API not supported.")
          }
          localMsg.onend = function(e) {
            callback();
          };
        };
        myInterpreter.setProperty(scope, 'say', myInterpreter.createAsyncFunction(speechWrapper));

        //display text
        var textWrapper = function(text) {
          text = text ? text.toString() : '';
          return myInterpreter.createPrimitive(document.getElementById('displayText').textContent = text);
        };
        myInterpreter.setProperty(scope, 'updateTextDisplay',
            myInterpreter.createNativeFunction(textWrapper));

      };
      //initializes myInterpreter
      var myInterpreter = new Interpreter(code,initFunc);
      //runs myInterpreter
      runButton(myInterpreter);
    };

    /**
     * Taken from JS Interpreter example
     * @param {Interpreter} myInterpreter The interpreter that is initialized and will run the code.
     */
    var runButton = function(myInterpreter) {
      if (myInterpreter.run()) {
        // Ran until an async call.  Give this call a chance to run. Then start running again later.
        setTimeout(runButton, 10, myInterpreter);
      }
    };
    
    /**
     * Used for logging messages from within the JS Interpreter. Prints it to the logging area and the console.
     * @param {Interpreter} myInterpreter The interpreter that is initialized and running the code.
     * @param {string} message The message that will be printed to the logging area and console
     */
    var logMessage = function(myInterpreter, message) {
      myInterpreter.createPrimitive(document.getElementById('logText').textContent = message);
      window.console.log(message);
    };
    
    /**
     * Add a word that the recognizer should be able to recognize from the user. Called from block code.
     * TODO (edauterman): Is there a good way to remove words after the user has changed them so that the grammar 
     * list doesn't get "clogged up" with words that are used and then changed? Is this worthwhile or unnecessary?
     * @param {string} word The word to be added to the list of recognizable words. 
     */

    var addRecognizableWord = function(word) {
      recognizableWords[recognizableWords.length] = word;
    };

    /**
     * Uses the recognizableWords to generate a string to give to the recognizer in updateGrammars.
     * @return {string} Returns the grammar string formatted correctly so that it can update the grammar of a
     * recognizer.
     */
    var convertRecognizableWordsToString = function() {
      var grammarString = '#JSGF V1.0; grammar phrase; public <phrase> = ';
      if (recognizableWords.length > 0) {
        grammarString += recognizableWords[0];
      }
      for (var i = 1; i < recognizableWords.length; i++) {
        grammarString += ' | ' + recognizableWords[i];
      }
      grammarString += ';';
      return grammarString;
    };

    /**
     * Takes as an argument the recognizer to update. Sets the settings using the grammar string and sets the
     * language to US English. 
     * TODO(edauterman): Should we add more choices for language for possible i18n?
     * @param {Recognizer} myRecognizer The recognizer to be updated.
     */

    var updateGrammars = function(myRecognizer) {
      var grammar = convertRecognizableWordsToString();
      var speechRecognitionList = new SpeechGrammarList();
      speechRecognitionList.addFromString(grammar, 1);
      myRecognizer.grammars = speechRecognitionList;
      myRecognizer.lang = 'en-US';
      myRecognizer.interimResults = false;
      myRecognizer.maxAlternatives = 1;
    };


  //TODO(quacht): add capability (new param called 'opt_append') for optionally appending the text rather than replacing it?
  var updateTextDisplay = function(newText){
    document.getElementById('displayText').textContent = newText;
  };

  </script>

</body>
</html>
